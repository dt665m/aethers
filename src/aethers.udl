namespace aethers {
  [Throws=WalletError]
  string ec_recover([ByRef] sequence<u8> signature, [ByRef] sequence<u8> message);

  [Throws=WalletError]
  Wallet decrypt_json_bytes([ByRef] sequence<u8> encrypted, [ByRef] sequence<u8> password, u64 chain_id);

  [Throws=WalletError]
  Wallet decrypt_json(string encrypted, string password, u64 chain_id);

  [Throws=WalletError]
  Wallet from_mnemonic(string mnemonic, string password, u64 chain_id);

  [Throws=ProviderError]
  ChainProvider provider_from_url([ByRef] string url);

  void init_logger();

  string impl_version();
};

[Error]
enum WalletError {
  "DerivationParse",
  "Mnemonic",
  "Signature",
  "Serde",
  "Encrypt",
  "Decrypt",
  "Utf8",
  "WrongPassword",
  "EthSignature",
  "Provider",
  "InsufficientGasFunds",
  "InvalidAddress",
  "AbiError",
};

interface Wallet {
  constructor(string password, u64 chain_id);

  sequence<string> request_accounts();

  [Throws=WalletError]
  string encrypt_json();

  [Throws=WalletError]
  string recover_phrase(string password);

  [Throws=WalletError]
  string sign_typed_message([ByRef] sequence<u8> message);

  [Throws=WalletError]
  string send_transaction(ChainProvider provider, string payload);

  [Throws=WalletError]
  string transfer_bridge_out(ChainProvider provider, string contract, string to, u64 value, u64 chain_id, u64 chain_type);

  [Throws=WalletError]
  string nft_mint(ChainProvider provider, string contract, string to, u64 value);

  [Throws=WalletError]
  string nft_safe_transfer_from(ChainProvider provider, string contract, string to, u64 token_id);

  [Throws=WalletError]
  string nft_owner_of(ChainProvider provider, string contract, u64 token_id);
  
  [Throws=WalletError]
  u64 nft_current_price(ChainProvider provider, string contract);

  [Throws=WalletError]
  u64 nft_total_supply(ChainProvider provider, string contract);
};

[Error]
enum ProviderError {
  "Runtime",
  "Parse",
  "Inner",
  "FromAddressMissing",
};

interface ChainProvider {
};
